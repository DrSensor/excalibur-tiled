{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///excalibur-tiled.min.js","webpack:///webpack/bootstrap bd6e643721e50b60ff69","webpack:///./src/index.ts","webpack:///external {\"commonjs\":\"excalibur\",\"commonjs2\":\"excalibur\",\"amd\":\"excalibur\",\"root\":\"ex\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__extends","extendStatics","setPrototypeOf","__proto__","Array","b","__","constructor","create","value","TiledMapFormat","excalibur_1","TiledResource","_super","path","mapFormat","JSON","_this","imagePathAccessor","indexOf","pp","split","relPath","concat","length","splice","push","join","load","Promise","then","map","promises","data","tilesets","forEach","ts","tx","Texture","image","imageTexture","Logger","getInstance","debug","apply","resolve","reject","processData","parseJsonMap","getTilesetForTile","gid","firstgid","getTileMap","TileMap","tilewidth","tileheight","height","width","_i","_a","cols","Math","floor","imagewidth","rows","imageheight","ss","SpriteSheet","registerSpriteSheet","toString","_b","_c","layers","layer","type","sprites","TileSprite","Resource","default","json","parse","encoding","decompressors","decompressBase64","decompressCsv","b64","decode","elt","code","charCodeAt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","v","arr","L","j","tmp","placeHolders","Error","Arr","Uint8Array","len","charAt","resultLen","result","byteArray","slice"],"mappings":"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","file":"excalibur-tiled.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"excalibur\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"excalibur\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Extensions.Tiled\"] = factory(require(\"excalibur\"));\n\telse\n\t\troot[\"Extensions.Tiled\"] = factory(root[\"ex\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"excalibur\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"excalibur\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Extensions.Tiled\"] = factory(require(\"excalibur\"));\n\telse\n\t\troot[\"Extensions.Tiled\"] = factory(root[\"ex\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar excalibur_1 = __webpack_require__(1);\r\nvar TiledMapFormat;\r\n(function (TiledMapFormat) {\r\n    /**\r\n     * TMX map layer format\r\n     * @unsupported\r\n     */\r\n    TiledMapFormat[TiledMapFormat[\"TMX\"] = 0] = \"TMX\";\r\n    /**\r\n     * JSON map layer format\r\n     */\r\n    TiledMapFormat[TiledMapFormat[\"JSON\"] = 1] = \"JSON\";\r\n})(TiledMapFormat = exports.TiledMapFormat || (exports.TiledMapFormat = {}));\r\nvar TiledResource = (function (_super) {\r\n    __extends(TiledResource, _super);\r\n    function TiledResource(path, mapFormat) {\r\n        if (mapFormat === void 0) { mapFormat = TiledMapFormat.JSON; }\r\n        var _this = this;\r\n        switch (mapFormat) {\r\n            case TiledMapFormat.JSON:\r\n                _this = _super.call(this, path, \"application/json\") || this;\r\n                break;\r\n            default:\r\n                throw \"The format \" + mapFormat + \" is not currently supported. Please export Tiled map as JSON.\";\r\n        }\r\n        _this.mapFormat = mapFormat;\r\n        _this.imagePathAccessor = function (p) {\r\n            // Use absolute path if specified\r\n            if (p.indexOf('/') === 0) {\r\n                return p;\r\n            }\r\n            // Load relative to map path\r\n            var pp = path.split('/');\r\n            var relPath = pp.concat([]);\r\n            if (pp.length > 0) {\r\n                // remove file part of path\r\n                relPath.splice(-1);\r\n            }\r\n            relPath.push(p);\r\n            return relPath.join('/');\r\n        };\r\n        return _this;\r\n    }\r\n    TiledResource.prototype.load = function () {\r\n        var _this = this;\r\n        var p = new excalibur_1.Promise();\r\n        _super.prototype.load.call(this).then(function (map) {\r\n            var promises = [];\r\n            // retrieve images from tilesets and create textures\r\n            _this.data.tilesets.forEach(function (ts) {\r\n                var tx = new excalibur_1.Texture(_this.imagePathAccessor(ts.image, ts));\r\n                ts.imageTexture = tx;\r\n                promises.push(tx.load());\r\n                excalibur_1.Logger.getInstance().debug(\"[Tiled] Loading associated tileset: \" + ts.image);\r\n            });\r\n            excalibur_1.Promise.join.apply(_this, promises).then(function () {\r\n                p.resolve(map);\r\n            }, function (value) {\r\n                p.reject(value);\r\n            });\r\n        });\r\n        return p;\r\n    };\r\n    TiledResource.prototype.processData = function (data) {\r\n        if (typeof data !== \"string\") {\r\n            throw \"Tiled map resource \" + this.path + \" is not the correct content type\";\r\n        }\r\n        if (data === void 0) {\r\n            throw \"Tiled map resource \" + this.path + \" is empty\";\r\n        }\r\n        switch (this.mapFormat) {\r\n            case TiledMapFormat.JSON:\r\n                return parseJsonMap(data);\r\n        }\r\n    };\r\n    TiledResource.prototype.getTilesetForTile = function (gid) {\r\n        for (var i = this.data.tilesets.length - 1; i >= 0; i--) {\r\n            var ts = this.data.tilesets[i];\r\n            if (ts.firstgid <= gid) {\r\n                return ts;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TiledResource.prototype.getTileMap = function () {\r\n        var map = new excalibur_1.TileMap(0, 0, this.data.tilewidth, this.data.tileheight, this.data.height, this.data.width);\r\n        // register sprite sheets for each tileset in map\r\n        for (var _i = 0, _a = this.data.tilesets; _i < _a.length; _i++) {\r\n            var ts = _a[_i];\r\n            var cols = Math.floor(ts.imagewidth / ts.tilewidth);\r\n            var rows = Math.floor(ts.imageheight / ts.tileheight);\r\n            var ss = new excalibur_1.SpriteSheet(ts.imageTexture, cols, rows, ts.tilewidth, ts.tileheight);\r\n            map.registerSpriteSheet(ts.firstgid.toString(), ss);\r\n        }\r\n        for (var _b = 0, _c = this.data.layers; _b < _c.length; _b++) {\r\n            var layer = _c[_b];\r\n            if (layer.type === \"tilelayer\") {\r\n                for (var i = 0; i < layer.data.length; i++) {\r\n                    var gid = layer.data[i];\r\n                    if (gid !== 0) {\r\n                        var ts = this.getTilesetForTile(gid);\r\n                        map.data[i].sprites.push(new excalibur_1.TileSprite(ts.firstgid.toString(), gid - ts.firstgid));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return map;\r\n    };\r\n    return TiledResource;\r\n}(excalibur_1.Resource));\r\nexports.default = TiledResource;\r\n/**\r\n * Handles parsing of JSON tiled data\r\n */\r\nvar parseJsonMap = function (data) {\r\n    var json = JSON.parse(data);\r\n    // Decompress layers\r\n    if (json.layers) {\r\n        for (var _i = 0, _a = json.layers; _i < _a.length; _i++) {\r\n            var layer = _a[_i];\r\n            if (typeof layer.data === \"string\") {\r\n                if (layer.encoding === \"base64\") {\r\n                    layer.data = decompressors.decompressBase64(layer.data, layer.encoding);\r\n                }\r\n            }\r\n            else {\r\n                layer.data = decompressors.decompressCsv(layer.data);\r\n            }\r\n        }\r\n    }\r\n    return json;\r\n};\r\n/**\r\n * Decompression implementations\r\n */\r\nvar decompressors = {\r\n    /**\r\n     * Simplest (passes data through since it's uncompressed)\r\n     */\r\n    decompressCsv: function (data) {\r\n        return data;\r\n    },\r\n    /**\r\n     * Uses base64.js implementation to decode string into byte array\r\n     * and then converts (with/without compression) to array of numbers\r\n     */\r\n    decompressBase64: function (b64, encoding) {\r\n        var i, j, l, tmp, placeHolders, arr;\r\n        if (b64.length % 4 > 0) {\r\n            throw new Error('Invalid string. Length must be a multiple of 4');\r\n        }\r\n        var Arr = (typeof Uint8Array !== 'undefined')\r\n            ? Uint8Array\r\n            : Array;\r\n        var PLUS = '+'.charCodeAt(0);\r\n        var SLASH = '/'.charCodeAt(0);\r\n        var NUMBER = '0'.charCodeAt(0);\r\n        var LOWER = 'a'.charCodeAt(0);\r\n        var UPPER = 'A'.charCodeAt(0);\r\n        var PLUS_URL_SAFE = '-'.charCodeAt(0);\r\n        var SLASH_URL_SAFE = '_'.charCodeAt(0);\r\n        function decode(elt) {\r\n            var code = elt.charCodeAt(0);\r\n            if (code === PLUS || code === PLUS_URL_SAFE)\r\n                return 62; // '+'\r\n            if (code === SLASH || code === SLASH_URL_SAFE)\r\n                return 63; // '/'\r\n            if (code < NUMBER)\r\n                return -1; // no match\r\n            if (code < NUMBER + 10)\r\n                return code - NUMBER + 26 + 26;\r\n            if (code < UPPER + 26)\r\n                return code - UPPER;\r\n            if (code < LOWER + 26)\r\n                return code - LOWER + 26;\r\n        }\r\n        // the number of equal signs (place holders)\r\n        // if there are two placeholders, than the two characters before it\r\n        // represent one byte\r\n        // if there is only one, then the three characters before it represent 2 bytes\r\n        // this is just a cheap hack to not do indexOf twice\r\n        var len = b64.length;\r\n        placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0;\r\n        // base64 is 4/3 + up to two characters of the original data\r\n        arr = new Arr(b64.length * 3 / 4 - placeHolders);\r\n        // if there are placeholders, only get up to the last complete 4 chars\r\n        l = placeHolders > 0 ? b64.length - 4 : b64.length;\r\n        var L = 0;\r\n        function push(v) {\r\n            arr[L++] = v;\r\n        }\r\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\r\n            tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));\r\n            push((tmp & 0xFF0000) >> 16);\r\n            push((tmp & 0xFF00) >> 8);\r\n            push(tmp & 0xFF);\r\n        }\r\n        if (placeHolders === 2) {\r\n            tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);\r\n            push(tmp & 0xFF);\r\n        }\r\n        else if (placeHolders === 1) {\r\n            tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);\r\n            push((tmp >> 8) & 0xFF);\r\n            push(tmp & 0xFF);\r\n        }\r\n        // Byte array\r\n        // TODO handle compression\r\n        var toNumber = function (byteArray) {\r\n            var value = 0;\r\n            for (var i = byteArray.length - 1; i >= 0; i--) {\r\n                value = (value * 256) + byteArray[i] * 1;\r\n            }\r\n            return value;\r\n        };\r\n        var resultLen = arr.length / 4;\r\n        var result = new Array(resultLen);\r\n        for (i = 0; i < resultLen; i++) {\r\n            result[i] = toNumber(arr.slice(i * 4, i * 4 + 3));\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// excalibur-tiled.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bd6e643721e50b60ff69","import {\r\n   Resource,\r\n   Promise,\r\n   Texture,\r\n   TileMap,\r\n   TileSprite,\r\n   SpriteSheet,\r\n   Logger\r\n} from 'excalibur';\r\nimport { ITiledMap, ITiledTileSet } from './ITiledMap';\r\n\r\nexport enum TiledMapFormat {\r\n\r\n   /**\r\n    * TMX map layer format\r\n    * @unsupported\r\n    */\r\n   TMX,\r\n\r\n   /**\r\n    * JSON map layer format\r\n    */\r\n   JSON\r\n}\r\n\r\nexport default class TiledResource extends Resource<ITiledMap> {\r\n\r\n   protected mapFormat: TiledMapFormat;\r\n\r\n   public imagePathAccessor: (path: string, ts: ITiledTileSet) => string;\r\n\r\n   constructor(path: string, mapFormat = TiledMapFormat.JSON) {\r\n      switch (mapFormat) {\r\n         case TiledMapFormat.JSON:\r\n            super(path, \"application/json\");\r\n            break;\r\n         default:\r\n            throw `The format ${mapFormat} is not currently supported. Please export Tiled map as JSON.`;\r\n      }\r\n\r\n      this.mapFormat = mapFormat;\r\n      this.imagePathAccessor = (p) => {\r\n\r\n         // Use absolute path if specified\r\n         if (p.indexOf('/') === 0) {\r\n            return p;\r\n         }\r\n\r\n         // Load relative to map path\r\n         let pp = path.split('/');\r\n         let relPath = pp.concat([]);\r\n\r\n         if (pp.length > 0) {\r\n            // remove file part of path\r\n            relPath.splice(-1);\r\n         }\r\n         relPath.push(p);\r\n         return relPath.join('/');\r\n      };\r\n   }\r\n\r\n   public load(): Promise<ITiledMap> {\r\n      var p = new Promise<ITiledMap>();\r\n\r\n      super.load().then(map => {\r\n\r\n         var promises: Promise<HTMLImageElement>[] = [];\r\n\r\n         // retrieve images from tilesets and create textures\r\n         this.data.tilesets.forEach(ts => {\r\n            var tx = new Texture(this.imagePathAccessor(ts.image, ts));\r\n            ts.imageTexture = tx;\r\n            promises.push(tx.load());\r\n\r\n            Logger.getInstance().debug(\"[Tiled] Loading associated tileset: \" + ts.image);\r\n         });\r\n\r\n         Promise.join.apply(this, promises).then(() => {\r\n            p.resolve(map);\r\n         }, (value?: any) => {\r\n            p.reject(value);\r\n         });\r\n      });\r\n\r\n      return p;\r\n   }\r\n\r\n   public processData(data: any): ITiledMap {\r\n      if (typeof data !== \"string\") {\r\n         throw `Tiled map resource ${this.path} is not the correct content type`;\r\n      }\r\n      if (data === void 0) {\r\n         throw `Tiled map resource ${this.path} is empty`;\r\n      }\r\n\r\n      switch (this.mapFormat) {\r\n         case TiledMapFormat.JSON:\r\n            return parseJsonMap(data);\r\n      }\r\n   }\r\n\r\n   public getTilesetForTile(gid: number): ITiledTileSet {\r\n      for (var i = this.data.tilesets.length - 1; i >= 0; i--) {\r\n         var ts = this.data.tilesets[i];\r\n\r\n         if (ts.firstgid <= gid) {\r\n            return ts;\r\n         }\r\n      }\r\n\r\n      return null;\r\n   }\r\n\r\n   public getTileMap(): TileMap {\r\n      var map = new TileMap(0, 0, this.data.tilewidth, this.data.tileheight, this.data.height, this.data.width);\r\n\r\n      // register sprite sheets for each tileset in map\r\n      for (var ts of this.data.tilesets) {\r\n         var cols = Math.floor(ts.imagewidth / ts.tilewidth);\r\n         var rows = Math.floor(ts.imageheight / ts.tileheight);\r\n         var ss = new SpriteSheet(ts.imageTexture, cols, rows, ts.tilewidth, ts.tileheight);\r\n\r\n         map.registerSpriteSheet(ts.firstgid.toString(), ss);\r\n      }\r\n\r\n      for (var layer of this.data.layers) {\r\n\r\n         if (layer.type === \"tilelayer\") {\r\n            for (var i = 0; i < layer.data.length; i++) {\r\n               let gid = <number>layer.data[i];\r\n\r\n               if (gid !== 0) {\r\n                  var ts = this.getTilesetForTile(gid);\r\n\r\n                  map.data[i].sprites.push(new TileSprite(ts.firstgid.toString(), gid - ts.firstgid))\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      return map;\r\n   }\r\n}\r\n\r\n/**\r\n * Handles parsing of JSON tiled data\r\n */\r\nvar parseJsonMap = (data: string): ITiledMap => {\r\n   var json = <ITiledMap>JSON.parse(data);\r\n\r\n   // Decompress layers\r\n   if (json.layers) {\r\n      for (var layer of json.layers) {\r\n\r\n         if (typeof layer.data === \"string\") {\r\n\r\n            if (layer.encoding === \"base64\") {\r\n               layer.data = decompressors.decompressBase64(<string>layer.data, layer.encoding);\r\n            }\r\n\r\n         } else {\r\n            layer.data = decompressors.decompressCsv(<number[]>layer.data);\r\n         }\r\n\r\n      }\r\n   }\r\n\r\n   return json;\r\n}\r\n\r\n/**\r\n * Decompression implementations\r\n */\r\nvar decompressors = {\r\n\r\n   /**\r\n    * Simplest (passes data through since it's uncompressed)\r\n    */\r\n   decompressCsv: (data: number[]) => {\r\n      return data;\r\n   },\r\n\r\n   /**\r\n    * Uses base64.js implementation to decode string into byte array\r\n    * and then converts (with/without compression) to array of numbers\r\n    */\r\n   decompressBase64: (b64: string, encoding: string) => {\r\n      var i: number,\r\n         j: number,\r\n         l: number,\r\n         tmp: number,\r\n         placeHolders: number,\r\n         arr: number[] | Uint8Array;\r\n\r\n      if (b64.length % 4 > 0) {\r\n         throw new Error('Invalid string. Length must be a multiple of 4')\r\n      }\r\n\r\n      var Arr = (typeof Uint8Array !== 'undefined')\r\n         ? Uint8Array\r\n         : Array;\r\n\r\n      var PLUS = '+'.charCodeAt(0);\r\n      var SLASH = '/'.charCodeAt(0);\r\n      var NUMBER = '0'.charCodeAt(0);\r\n      var LOWER = 'a'.charCodeAt(0);\r\n      var UPPER = 'A'.charCodeAt(0);\r\n      var PLUS_URL_SAFE = '-'.charCodeAt(0);\r\n      var SLASH_URL_SAFE = '_'.charCodeAt(0);\r\n\r\n      function decode(elt) {\r\n         var code = elt.charCodeAt(0)\r\n         if (code === PLUS || code === PLUS_URL_SAFE) return 62 // '+'\r\n         if (code === SLASH || code === SLASH_URL_SAFE) return 63 // '/'\r\n         if (code < NUMBER) return -1 // no match\r\n         if (code < NUMBER + 10) return code - NUMBER + 26 + 26\r\n         if (code < UPPER + 26) return code - UPPER\r\n         if (code < LOWER + 26) return code - LOWER + 26\r\n      }\r\n\r\n      // the number of equal signs (place holders)\r\n      // if there are two placeholders, than the two characters before it\r\n      // represent one byte\r\n      // if there is only one, then the three characters before it represent 2 bytes\r\n      // this is just a cheap hack to not do indexOf twice\r\n      var len = b64.length\r\n      placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0\r\n\r\n      // base64 is 4/3 + up to two characters of the original data\r\n      arr = new Arr(b64.length * 3 / 4 - placeHolders)\r\n\r\n      // if there are placeholders, only get up to the last complete 4 chars\r\n      l = placeHolders > 0 ? b64.length - 4 : b64.length\r\n\r\n      var L = 0\r\n\r\n      function push(v) {\r\n         arr[L++] = v\r\n      }\r\n\r\n      for (i = 0, j = 0; i < l; i += 4, j += 3) {\r\n         tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\r\n         push((tmp & 0xFF0000) >> 16)\r\n         push((tmp & 0xFF00) >> 8)\r\n         push(tmp & 0xFF)\r\n      }\r\n\r\n      if (placeHolders === 2) {\r\n         tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\r\n         push(tmp & 0xFF)\r\n      } else if (placeHolders === 1) {\r\n         tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\r\n         push((tmp >> 8) & 0xFF)\r\n         push(tmp & 0xFF)\r\n      }\r\n\r\n      // Byte array\r\n      // TODO handle compression\r\n\r\n      var toNumber = function (byteArray: number[] | Uint8Array) {\r\n         var value = 0;\r\n\r\n         for (var i = byteArray.length - 1; i >= 0; i--) {\r\n            value = (value * 256) + byteArray[i] * 1;\r\n         }\r\n\r\n         return value;\r\n      };\r\n\r\n      var resultLen = arr.length / 4;\r\n      var result = new Array<number>(resultLen);\r\n\r\n      for (i = 0; i < resultLen; i++) {\r\n         result[i] = toNumber(arr.slice(i * 4, i * 4 + 3));\r\n      }\r\n\r\n      return result;\r\n   }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"excalibur\",\"commonjs2\":\"excalibur\",\"amd\":\"excalibur\",\"root\":\"ex\"}\n// module id = 1\n// module chunks = 0 1"],"sourceRoot":""}